<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="@renerocksai - personal website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@renerocksai">
    <meta name="twitter:author" content="@renerocksai">
    <meta name="twitter:description" content="@renerocksai - personal website">
    <meta name="twitter:title" content="Blobz : Your wobbly Garbage Persistor | @renerocksai">
    <meta name="twitter:image" content="https://renerocks.ai/reneglasses.png">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Blobz : Your wobbly Garbage Persistor | @renerocksai">
    <meta property="og:image" content="https://renerocks.ai/reneglasses.png">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      Blobz : Your wobbly Garbage Persistor
      - @renerocksai
    </title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&family=Montserrat:wght@700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/main.css">
    <link rel="stylesheet" type="text/css" href="/highlight.css">
    
  <link type="text/css" rel="stylesheet" href="/term-highlight.css">
  <style>
    #docs {
        h1, h2, h3, h4 {
            text-align: left;
            a {
                color: black;
                text-decoration: none;
            }
        }
        @media (prefers-color-scheme:dark) {
          h1, h2, h3, h4 {
            a {
              color: white;
            }
          }
        }

        h2 {
            font-size: 1.5rem;
            border-bottom: 1px dashed #aaa;
            margin-top: 2em;
            a:hover::after {
                content: ' #';
            }
        }

        h3 {
            font-size: 1.5rem;
            a:hover::after {
                content: ' ##';
            }
        }

        h4 {
            font-size: 1rem;
            a:hover::after {
                content: ' ###';
            }
        }

    }

    table {
        font-size: 0.9em;
    }
    table th {
        font-size: 1em;
    }
    table td {
        white-space: nowrap;
    }
  </style>

  </head>
  <body>
    <div id="content">
      
  <div style="display:flex; flex-direction:column; align-items:center;">
    <h1 id="header" class="noupper" style="color: #606060"><a class="reset-a" href="/">@renerocksai</a></h1>
    <div class="menu-small" style="display:flex; justify-content:center; font-size:small;">
      <a href="/">Home</a>
      ‚Ä¢
      <a href="/blog/">Blog</a>
      ‚Ä¢
      <a href="/projects/">Projects</a>
      ‚Ä¢
      <a href="/about/">About</a>
      ‚Ä¢
      <a href="https://github.com/renerocksai" target="_blank">
        GitHub
      </a>
    </div>
  </div>
  <h1>Blobz : Your wobbly Garbage Persistor</h1>
  <p class="post-byline">
    <span>March 17, 2025</span>
    ‚Ä¢
    <span>8</span>
    min read ‚Ä¢ by
    <b>renerocksai</b>
    <span></span>
  </p>
  <div id="post-description"></div>
  <div></div>
  <div id="docs">
    <div id="post-body"><p><img src="/blobz.jpeg" alt=""></p><h2>This is Vaporware! üí®</h2><p>Yet I‚Äôve wanted to build it for a while now.</p><p>I‚Äôm probably going to build it gradually, one step at a time‚Äîtreating it as both a useful tool for my own projects and an experiment to explore how far I can push the idea. What idea, you ask? A GC-style in-process key-value store with persistence, built in Zig.</p><p>I know hardly anyone is ever going to read this piece, but: if you do and you have opinions, please share them with me on <a href="https://x.com/renerocksai" target="_blank">X</a> or hop onto the <a href="https://discord.gg/jQAAN6Ubyj" target="_blank">Zap Discord Server</a> and tell me why my approach sucks, if you have better ideas, what <strong>existing</strong> solution I should use instead, etc.</p><p>Heads up: it‚Äôs going to be <a href="https://ziglang.org" target="_blank">Zig</a>.</p><p>What follows is me rambling about a pet project I wanted to start a long time ago but never <em>really</em> needed to, because my Zap apps were so robust that I was never <em>forced</em> to do it.</p><p>When you read this, there might even be something to look at on <a href="https://github.com/renerocksai/blobz" target="_blank">GitHub</a>.</p><h2>Intro : Garbage Collection Style Persistence</h2><p>What I have in mind is an in-process key/value store with the following characteristics, vaguely inspired by mark-and-sweep garbage collection:</p><ul><li>it is meant for multithreaded environments like <a href="https://github.com/zigzap/zap" target="_blank">Zap</a> apps.</li><li>you define key and value types<ul><li><em>I think of a specialization where the key is just an index into an array.</em></li></ul></li><li>you can iterate through it fast if you need to (ArrayHashMap)</li><li>it has an <code>upsert</code> method: you can insert/update the value under a key</li><li>it marks timestamps of upserts as <code>dirty_time</code>.</li><li>it runs a ‚Äúgarbage persistor‚Äù in its own thread:<ul><li>iterates through all objects</li><li>it knows when it last ran (<code>last_garbage_run</code>).</li><li>all objects whose <code>dirty_time &gt; last_garbage_run</code> will be snapshotted into JSON (for now)</li><li>the collected JSONs are persisted to disk</li></ul></li><li>you can bootstrap it from persisted JSON.</li></ul><h2>Why This Might Actually Be Useful?</h2><p>Consider the following (‚Äúmy‚Äù) scenario: You run an online experiment. The moment you take it live, hundreds or even thousands of users waiting for a new challenge might storm your site. With every action they take, they change their user state. Per-user state changes can be quite frequent‚Äîmaybe even automated by some JavaScript that hits an API endpoint every half a second or so to keep track of some very important, granular progress.</p><p>The frequent updates to the server are meant to ensure accurate information on a dashboard you might create and, more importantly, that users can close their browsers and resume to almost exactly the previous state, even on a different computer, i.e., not relying on client-side storage.</p><p>While my scenario happens in the context of online experiments, similar characteristics might apply to other web apps. If not, then Blobz will be just for me. üòä</p><h3>In-process</h3><p>I love <a href="https://www.sqlite.org" target="_blank">SQLite</a>. An in-process database. Simple to deploy, battle-tested in the millions of millions (probably). No database connections, no shit. You link to it and that‚Äôs it. Now your app can database. Actually, now your app <em>IS</em> a database.</p><p>What I don‚Äôt love about SQLite is its SQLiness. I often don‚Äôt want schemas, tables, columns, etc. I‚Äôd rather have a persistent copy of an array or HashMap. I don‚Äôt want to translate zig structs to SQL tables.</p><p>Having such persistence <em>in-process</em> is valuable to me, as it simplifies building and deployment. Just <code>zig buid</code> to build. True, that can also be achieved with SQLite, but I hope you get the idea. To deploy, just start the one and only process. No need to spin up a docker-compose with a <a href="https://redis.io" target="_blank">Redis</a>, for example.</p><h3>Starting Simple‚Ä¶</h3><p>Blobz, with its limited scope, seems like a good candidate to grow from a basic proof-of-concept to a basic production-ready version - and then experimenting with alternative, even more robust/performant/better implementations.</p><p>For a start, if it can provide SQLite-like or better performance and robustness as a storage layer, I‚Äôd call it a first success.</p><p>What follows, is me rambling about some implementation details that came to mind before starting to write the first line of code‚Ä¶</p><h2>Locking and JSON: First Experiments in Persistence</h2><p>The first approach to getting to a working solution is locking the entire HashMap of users to iterate over its KV pairs and persisting them. It‚Äôs also not the most performant. Conversion to JSON is not super-efficient. This approach slows down your entire experiment app for all users until all JSON conversions are done.</p><p>Well, we could take a COPY of each value, essentially creating a snapshot of the entire HashMap (via many individual value snapshots), then slowly convert to JSON and persist it. That seems like a sensible approach. But what if user objects might be large and constantly growing? It seems like a waste of memory to convert them all in one go. So we iterate, then copy, and jsonify individual user objects.</p><p>We need to discuss object consistency here. What if the object changes while we‚Äôre taking the copy? The resulting copy might be in an inconsistent state. We can mitigate that by introducing read/write locks to the user objects.</p><p>Now that we can briefly lock objects, we don‚Äôt want to hold the locks for too long, as that might slow down our app. You might think, ‚ÄúLet‚Äôs take copies. It‚Äôs OK to waste a bit of memory and then jsonify all the copies in one go.‚Äù</p><p>But what is a copy? How deep or shallow is it? Only their <code>.ptr</code> and <code>.len</code> fields are copied if a user object holds data slices. That‚Äôs a problem. Suppose the app deletes the user object and frees its associated memory after we‚Äôve taken the copy but before we could jsonify it. In that case, our copy holds slices with invalidated pointers.</p><p>This is where we contemplate abandoning the idea of copying. Sure, we could impose on our app to never delete and destroy any user objects. We could also deep-copy all slices and the slices they might contain, etc. Or we could impose on user objects that they must not hold slices that point outside their memory. They must contain fixed buffers for every slice, so the slices only ever point to memory, which is part of the object itself. Of course, we would then need to correct the pointers in the copies. That doesn‚Äôt seem like a good idea. Instead, we could impose on the user struct to have a <code>clone(alloc)</code> method. Now, I hope you understand why we abandoned the idea of copying. None of the approaches mentioned above seem right. However, I might revisit that thought later if Blobz‚Äôs performance turns out to be terrible. üòä</p><p>So let‚Äôs try this: we add a read/write lock to every user object. Our garbage persistor only locks user objects when taking a copy and jsonifying. Our app makes sure to make changes in ‚Äútransactions‚Äù by acquiring the write lock. So when we jsonify = read objects, they‚Äôll always be in a valid state. Acquiring the write lock also immediately marks the object as dirty.</p><h2>How should the persistence ACTUALLY work?</h2><p>That‚Äôs actually the wrong question. Because nothing is good enough until it has reached <a href="https://tigerbeetle.com" target="_blank">TigerBeetle</a> level.</p><p>So the question should rather be: How can we organize persistence so we can avoid the most obvious traps?</p><p>For one, let‚Äôs not store everything in one big JSON file. Instead, let‚Äôs write objects into individual files. At least in the past, some filesystems (especially on Windows) did not cope well with large directories. So we better create subdirectories and limit the number of files in them. Everybody does it, even git.</p><p>Here, an interesting question arises: how can we make persistence robust in the sense that a crash while writing does not leave inconsistent state in the file representation? Something like writing into <code>.json.tmp</code> files and renaming them to <code>.json</code> later.</p><p>I guess more inspiration will come automatically once we start writing and testing some code.</p><h2>The Big Flaw(s)</h2><p>Our persistence is naive. It relies on the file system and its surrounding infrastructure (e.g. kernel, <code>fsync</code>). Until I have found a better solution, this will have to do. <a href="https://tigerbeetle.com" target="_blank">TigerBeetle</a> fans will probably stop reading now and that‚Äôs OK. We‚Äôre close to the end anyway ü§£.</p><p>Oh, and speaking of flaws, the elephant in the room is JSON. I know. But it‚Äôs an easy fix for now, and it‚Äôs human-readable, too.</p><h2>Room for Improvement</h2><p>Improvements I can think of and want to tackle:</p><h3>No JSON</h3><p>Objects implementing a persistence method, analog to <code>pub fn format(...)</code>, could get us out of the JSON hell for those structures that implement them:</p><pre><code class="zig"><span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">toBlobz</span><span class="punctuation bracket">(</span><span class="variable parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="function builtin">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
               <span class="variable parameter">alloc</span><span class="punctuation delimiter">:</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">mem</span><span class="punctuation delimiter">.</span><span class="variable member">Allocator</span><span class="punctuation bracket">)</span> <span class="operator">!</span><span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">;</span>
<span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">fromBlobz</span><span class="punctuation bracket">(</span><span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation bracket">)</span> <span class="operator">!</span><span class="function builtin">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">writeBlobz</span><span class="punctuation bracket">(</span><span class="variable parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="function builtin">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable parameter">writer</span><span class="punctuation delimiter">:</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">io</span><span class="punctuation delimiter">.</span><span class="variable member">Writer</span><span class="punctuation bracket">)</span> <span class="operator">!</span><span class="type builtin">void</span><span class="punctuation delimiter">;</span>
<span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">readBlobz</span><span class="punctuation bracket">(</span><span class="variable parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="function builtin">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable parameter">writer</span><span class="punctuation delimiter">:</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">io</span><span class="punctuation delimiter">.</span><span class="variable member">Reader</span><span class="punctuation bracket">)</span> <span class="operator">!</span><span class="type builtin">void</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>or similar.</p><h3>Better Data Partitioning</h3><p>We might soon abandon the idea of storing one file per object and switch to more optimal partitioning of data.</p><p>While we‚Äôre at it, we might want to explore imposing a size limit on persisted object state, and working just with memory mapped files.</p><h2>Where to go from here.</h2><p>I created a <a href="/projects/blobz/">project page for Blobz</a>, which I‚Äôll populate with links to anything useful related to the project, like follow-up articles, until Blobz can stand on its own feet. ü¶∂ ü¶∂</p><p><strong>TL;DR:</strong> I need this. So I‚Äôm building it. Let‚Äôs see how far it can go. ü§†</p></div>
  </div>
  <hr>
  <div id="prev-next">
    <span>
      <a href="/blog/jj-sync-remote/">‚Üê
        <span>Syncing a local Jujutsu repo with remote changes</span></a>
    </span>
    <span>&nbsp; ‚Ä¢ &nbsp;</span>
    <span>
      <a href="/blog/why-paper/"><span>You Need a Sheet of Paper</span>
        ‚Üí</a>
    </span>
    <small>&nbsp; or &nbsp;</small>
    <small>
      <a href="/">Back to the Homepage</a>
    </small>
  </div>

    </div>
    <footer id="footer">
      
    </footer>
  </body>
</html>
