<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="@renerocksai - personal website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@renerocksai">
    <meta name="twitter:author" content="@renerocksai">
    <meta name="twitter:description" content="@renerocksai - personal website">
    <meta name="twitter:title" content="Binding Methods in Zig | @renerocksai">
    <meta name="twitter:image" content="https://renerocks.ai/reneglasses.png">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Binding Methods in Zig | @renerocksai">
    <meta property="og:image" content="https://renerocks.ai/reneglasses.png">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      Binding Methods in Zig
      - @renerocksai
    </title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&family=Montserrat:wght@700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/main.css">
    <link rel="stylesheet" type="text/css" href="/highlight.css">
    
  <link type="text/css" rel="stylesheet" href="/term-highlight.css">
  <style>
    #docs {
        h1, h2, h3, h4 {
            text-align: left;
            a {
                color: black;
                text-decoration: none;
            }
        }
        @media (prefers-color-scheme:dark) {
          h1, h2, h3, h4 {
            a {
              color: white;
            }
          }
        }

        h2 {
            font-size: 1.5rem;
            border-bottom: 1px dashed #aaa;
            margin-top: 2em;
            a:hover::after {
                content: ' #';
            }
        }

        h3 {
            font-size: 1.5rem;
            a:hover::after {
                content: ' ##';
            }
        }

        h4 {
            font-size: 1rem;
            a:hover::after {
                content: ' ###';
            }
        }

    }

    table {
        font-size: 0.9em;
    }
    table th {
        font-size: 1em;
    }
    table td {
        white-space: nowrap;
    }
  </style>

  </head>
  <body>
    <nav>
      <div class="navleft noupper" style="z-index:10">
        <span>@</span><a href="https://renerocks.ai/">renerocksai</a>
      </div>
      <div class="spacer"></div>
      <button class="hamburger" aria-label="Toggle menu">
         &#9776;
        <!-- Unicode for hamburger icon (☰) -->
      </button>
      <div class="menu">
        <a href="/">Home</a>
        <a href="/blog/">Blog</a>
        <a href="/projects/">Projects</a>
        <a href="/about/">About</a>
        <a href="https://github.com/renerocksai" target="_blank">
          GitHub
        </a>
      </div>
      <div class="spacer"></div>
    </nav>
    <div id="content">
      
  <h1>Binding Methods in Zig</h1>
  <p class="post-byline">
    <span>March 26, 2025</span>
    •
    <span>27</span>
    min read • by
    <b>renerocksai</b>
    <span></span>
  </p>
  <div id="post-description"></div>
  <div>
    <div class="toc block info">
      <h1>&nbsp;Table of Contents</h1>
      <div><ul>
<li>
<ul><li>
The Challenge in Zig</li><li>Exploring Initial Approaches<ul><li>
Attempt 1: The Runtime Closure Misconception</li><li>Attempt 2: A Generic Wrapper Struct (Explicit Bundling)</li><li>Attempt 3: The Nested Interface and <code>@fieldParentPtr</code></li></ul></li><li>The Solution: Decoupling Binding and Interface</li><li>Relation to Standard Zig Interfaces (VTable Pattern)<ul><li>
Trade-offs</li><li>Conclusion</li></ul></li></ul></ul></div>
    </div>
  </div>
  <div id="docs">
    <div id="post-body"><p>In object-oriented languages like Python, passing instance methods around as callbacks is incredibly convenient. The language handles the complexity of ensuring the method knows which instance (<code>self</code>) it belongs to. Consider a simple event handler:</p><pre><code class="python"><span class="keyword">class</span> <span class="variable">Greeter</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="variable">self</span>, <span class="variable">name</span>):
        <span class="variable">self</span>.<span class="property">name</span> <span class="operator">=</span> <span class="variable">name</span>

    <span class="keyword">def</span> <span class="function">say_hello</span>(<span class="variable">self</span>):
        <span class="comment"># This method needs &apos;self&apos; (the instance context)</span>
        <span class="function">print</span>(<span class="string">f&quot;Hello from {self.name}!&quot;</span>)

<span class="comment"># Some hypothetical API function that takes a callback</span>
<span class="keyword">def</span> <span class="function">register_callback</span>(<span class="variable">callback_func</span>):
    <span class="function">print</span>(<span class="string">&quot;Registering callback...&quot;</span>)
    <span class="comment"># Later, the API invokes the callback</span>
    <span class="function">callback_func</span>()

<span class="comment"># --- Usage ---</span>
<span class="variable">greeter_instance</span> <span class="operator">=</span> <span class="function">Greeter</span>(<span class="string">&quot;Alice&quot;</span>)

<span class="comment"># We can pass the *bound method* directly!</span>
<span class="comment"># Python implicitly captures &apos;self&apos; (greeter_instance)</span>
<span class="function">register_callback</span>(<span class="variable">greeter_instance</span>.<span class="property">say_hello</span>)

<span class="comment"># Output:</span>
<span class="comment"># Registering callback...</span>
<span class="comment"># Hello from Alice!</span>
</code></pre>
<p>The “bound method” <code>greeter_instance.say_hello</code> is more than just a function pointer; it’s an object packaging the function <em>and</em> the instance (<code>greeter_instance</code>). When invoked, Python ensures <code>say_hello</code> receives the correct <code>self</code>.</p><h2>The Challenge in Zig</h2><p>Zig, prioritizing explicitness and control, lacks this implicit binding. A “method” is typically just a function taking a pointer to a struct as its first argument (<code>self</code>). This creates a mismatch when interacting with APIs expecting simple function pointers.</p><p>Imagine a Zig API wanting a simple callback:</p><pre><code class="zig"><span class="keyword">const</span> <span class="variable">std</span> <span class="operator">=</span> <span class="keyword import">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="comment">// Hypothetical API expecting a simple function pointer</span>
<span class="keyword function">fn</span> <span class="function">registerCallback</span><span class="punctuation bracket">(</span><span class="variable parameter">callback_fn</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="keyword function">fn</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">debug</span><span class="punctuation delimiter">.</span><span class="function call">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Registering Zig callback...\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="function call">callback_fn</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword">const</span> <span class="variable">Greeter</span> <span class="operator">=</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
    <span class="variable member">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>

    <span class="comment">// Needs &apos;*Greeter&apos; as the first argument</span>
    <span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">sayHello</span><span class="punctuation bracket">(</span><span class="variable parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">Greeter</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
        <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">debug</span><span class="punctuation delimiter">.</span><span class="function call">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Hello from {s}!\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">name</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

<span class="comment">// --- Attempted Usage ---</span>
<span class="keyword">test</span> <span class="string">&quot;direct callback fails&quot;</span> <span class="punctuation bracket">{</span>
    <span class="keyword">var</span> <span class="variable">greeter_instance</span> <span class="punctuation delimiter">:</span> <span class="variable">Greeter</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="variable member">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

    <span class="comment">// This WON&apos;T compile!</span>
    <span class="comment">// registerCallback(&amp;Greeter.sayHello);</span>
    <span class="comment">// Error: Expected &apos;*const fn () void&apos;, found &apos;*const fn (*const main.Greeter) void&apos;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>The API expects <code>fn() void</code>, but <code>Greeter.sayHello</code> requires a <code>*const Greeter</code> context. How do we bridge this gap and supply the necessary <code>self</code> pointer?</p><h2>Exploring Initial Approaches</h2><p>Before arriving at the final <code>CallbackInterface</code> pattern, let’s walk through the thought process. How might we tackle this problem in Zig initially, and what challenges arise? Understanding these steps is key to appreciating the final design.</p><p><strong>The Core Problem Recap:</strong> An API expects a simple function pointer like <code>*const fn(ArgType) void</code>. Our goal is to pass something that acts like an instance method, effectively <code>fn(self: *MyInstance, ArgType) void</code>, giving the callback access to instance data (<code>self</code>).</p><h3>Attempt 1: The Runtime Closure Misconception</h3><p>A common pattern in other languages involves functions or methods “closing over” variables from their surrounding scope. Can we leverage this in Zig? Let’s try defining a struct with a method <em>inside</em> a function, attempting to access that function’s arguments or local variables that hold runtime state:</p><pre><code class="zig"><span class="keyword">const</span> <span class="variable">std</span> <span class="operator">=</span> <span class="keyword import">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="comment">// --- The Goal ---</span>
<span class="comment">// An instance type with a method needing &apos;self&apos;</span>
<span class="keyword">const</span> <span class="variable">Greeter</span> <span class="operator">=</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
    <span class="variable member">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
    <span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">sayHello</span><span class="punctuation bracket">(</span><span class="variable parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">Greeter</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
        <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">debug</span><span class="punctuation delimiter">.</span><span class="function call">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Hello from {s}!\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">name</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="comment">// An API expecting a simple callback without context</span>
<span class="keyword function">fn</span> <span class="function">registerCallback</span><span class="punctuation bracket">(</span><span class="variable parameter">callback_fn</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="keyword function">fn</span> <span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">debug</span><span class="punctuation delimiter">.</span><span class="function call">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Registering callback...\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="function call">callback_fn</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="comment">// --- The Attempt ---</span>
<span class="comment">// A function that takes the instance as a RUNTIME argument</span>
<span class="keyword function">fn</span> <span class="function">setupAndRegisterCallback</span><span class="punctuation bracket">(</span><span class="variable parameter">instance</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">Greeter</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="comment">// Define a struct locally inside the function</span>
    <span class="keyword">const</span> <span class="variable">LocalGreeterWrapper</span> <span class="operator">=</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
        <span class="comment">// Attempt to define a method that uses the outer function&apos;s &apos;instance&apos; argument</span>
        <span class="keyword function">fn</span> <span class="function">cb</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
            <span class="comment">// PROBLEM: Try to access &apos;instance&apos; from setupAndRegisterCallback</span>
            <span class="variable">instance</span><span class="punctuation delimiter">.</span><span class="function call">sayHello</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span> <span class="comment">// This line causes the error</span>
        <span class="punctuation bracket">}</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

    <span class="comment">// Try to pass the nested method to the API</span>
    <span class="function call">registerCallback</span><span class="punctuation bracket">(</span><span class="variable">LocalGreeterWrapper</span><span class="punctuation delimiter">.</span><span class="variable member">cb</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword">test</span> <span class="string">&quot;Local Struct Method Access Runtime State&quot;</span> <span class="punctuation bracket">{</span>
    <span class="keyword">const</span> <span class="variable">greeter_instance</span> <span class="operator">=</span> <span class="variable">Greeter</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="comment">// Pass the runtime instance pointer to the setup function</span>
    <span class="function call">setupAndRegisterCallback</span><span class="punctuation bracket">(</span><span class="operator">&amp;</span><span class="variable">greeter_instance</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>This attempt fails to compile with a clear error:</p><pre><code>error: &apos;instance&apos; not accessible from inner function
            instance.sayHello();
            ^~~~~~~~
note: crossed function definition here
        fn cb() void {
        ^~~~~~~~~~~~
</code></pre><p><strong>Why it Fails (Runtime vs. Compile-Time):</strong></p><p>The error message “<code>&apos;instance&apos; not accessible from inner function</code>” highlights a key aspect of Zig: functions and methods <strong>do not form runtime closures</strong>.</p><ul><li>The <code>instance</code> parameter passed to <code>setupAndRegisterCallback</code> is a <strong>runtime</strong> value (a pointer whose specific address is known only during execution).</li><li>The method <code>LocalGreeterWrapper.cb</code>, although defined textually <em>within</em> <code>setupAndRegisterCallback</code>, is compiled into fixed code. This code has no built-in mechanism to dynamically access runtime variables or parameters (like <code>instance</code>) belonging to the specific stack frame of an outer <em>runtime</em> function (<code>setupAndRegisterCallback</code>) that might be active when <code>cb</code> is invoked.</li></ul><p> </p><div class="block warning"><h1>Important Distinction: Compile-Time Context is Accessible</h1><p>Above limitation applies specifically to capturing <em>runtime</em> state from outer <em>runtime</em> scopes. If an outer scope involves <strong>compile-time known values</strong> (e.g., function parameters in a <code>comptime</code> function, <code>const</code> values evaluated at compile time), methods of nested structs <em>can</em> access those. This is because the compiler can embed or directly reference these known values when generating the code for the nested methods.</p></div><pre><code class="zig"><span class="comment">// Example: Accessing comptime context</span>
<span class="keyword function">fn</span> <span class="function">makeStructWithComptimeData</span><span class="punctuation bracket">(</span><span class="keyword modifier">comptime</span> <span class="variable parameter">prefix</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
    <span class="keyword">const</span> <span class="variable">suffix</span> <span class="operator">=</span> <span class="string">&quot;-end&quot;</span><span class="punctuation delimiter">;</span> <span class="comment">// Compile-time known const</span>
    <span class="keyword return">return</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
        <span class="keyword function">fn</span> <span class="function">getMessage</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span> <span class="punctuation bracket">{</span>
            <span class="comment">// OK: Accessing &apos;comptime prefix&apos; and &apos;const suffix&apos;</span>
            <span class="keyword return">return</span> <span class="variable">prefix</span> <span class="operator">++</span> <span class="variable">suffix</span><span class="punctuation delimiter">;</span>
        <span class="punctuation bracket">}</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
<span class="keyword">test</span> <span class="string">&quot;comptime context access&quot;</span> <span class="punctuation bracket">{</span>
    <span class="keyword">const</span> <span class="variable">S</span> <span class="operator">=</span> <span class="function call">makeStructWithComptimeData</span><span class="punctuation bracket">(</span><span class="string">&quot;start&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword exception">try</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">testing</span><span class="punctuation delimiter">.</span><span class="function call">expectEqualStrings</span><span class="punctuation bracket">(</span><span class="string">&quot;start-end&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">S</span><span class="punctuation delimiter">.</span><span class="function call">getMessage</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>However, accessing compile-time context doesn’t solve our core callback problem. The callback needs access to the specific <em>runtime instance data</em> passed into <code>setupAndRegisterCallback</code>. Zig requires an explicit mechanism to bundle this runtime context with the function pointer, rather than relying on implicit runtime closures.</p><h3>Attempt 2: A Generic Wrapper Struct (Explicit Bundling)</h3><p>Let’s create a dedicated struct to hold the two essential pieces of information: the pointer to the specific instance (<code>*Instance</code>) and a pointer to the code of the instance method we want to call (<code>*const MethodFunc</code>).</p><pre><code class="zig"><span class="keyword function">fn</span> <span class="function">BindAttempt2</span><span class="punctuation bracket">(</span><span class="variable parameter">Instance</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation delimiter">,</span> <span class="variable parameter">MethodFunc</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
    <span class="comment">// Assume MethodFunc is the type of the instance method, e.g., fn(*Instance, Args...)</span>
    <span class="keyword return">return</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
        <span class="variable member">instance_ptr</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">Instance</span><span class="punctuation delimiter">,</span>
        <span class="variable member">method_ptr</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">MethodFunc</span><span class="punctuation delimiter">,</span>

        <span class="comment">// ... Now what? ...</span>
        <span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="variable parameter">inst</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">Instance</span><span class="punctuation delimiter">,</span> <span class="variable parameter">meth</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">MethodFunc</span><span class="punctuation bracket">)</span> <span class="function builtin">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
             <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">instance_ptr</span> <span class="operator">=</span> <span class="variable">inst</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable member">method_ptr</span> <span class="operator">=</span> <span class="variable">meth</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
        <span class="punctuation bracket">}</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="comment">// Usage:</span>
<span class="comment">// var greeter_instance = Greeter{.name = &quot;Alice&quot;};</span>
<span class="comment">// var binding = BindAttempt2(Greeter, @TypeOf(&amp;Greeter.sayHello)).init(&amp;greeter_instance, &amp;Greeter.sayHello);</span>
</code></pre>
<p>This struct successfully <em>stores</em> the context (<code>binding.instance_ptr</code>) and the function (<code>binding.method_ptr</code>). But we’re still stuck on the original problem: how do we give the API (expecting <code>*const fn() void</code>) something it can actually call? We can’t just give it a pointer to the <code>binding</code> struct. We need a plain function pointer that somehow uses the data <em>inside</em> <code>binding</code>.</p><h3>Attempt 3: The Nested Interface and <code>@fieldParentPtr</code></h3><p>This approach tries to leverage more of Zig’s specific features. The idea is to embed a small “interface” struct within our main wrapper (<code>BoundFunction</code>). The API would interact with a pointer to this nested interface. We then need the function called <em>via</em> this interface pointer to somehow retrieve the context (the <code>instance</code> and <code>method</code> pointers) stored in the parent <code>BoundFunction</code> struct.</p><p>Zig provides a builtin function, <code>@fieldParentPtr</code>, designed for similar scenarios. Given a pointer to a field <em>within</em> a struct, along with the parent struct type and the field name, <code>@fieldParentPtr</code> calculates the memory address of the beginning of that parent struct instance.</p><p>The structure would look something like this conceptually:</p><ol><li>The main <code>BoundFunction</code> struct holds <code>instance</code> and <code>method</code> pointers.</li><li>A nested <code>BindInterface</code> struct is defined inside <code>BoundFunction</code>. It contains a single <code>call</code> function pointer field.</li><li>This <code>call</code> pointer points to a static helper function (let’s call it <code>callHelper</code>) also defined within <code>BoundFunction</code>.</li><li>Crucially, <code>callHelper</code> would be designed to take a pointer <em>to the <code>BindInterface</code> field itself</em> as its first argument.</li><li>Inside <code>callHelper</code>, <code>@fieldParentPtr</code> would be used: “Given this pointer to the <code>interface_</code> field, find the <code>BoundFunction</code> that contains it.”</li><li>Once <code>callHelper</code> retrieves the <code>BoundFunction</code> pointer (<code>self</code>), it can access <code>self.instance</code> and <code>self.method</code> to perform the actual call.</li></ol><pre><code class="zig"><span class="comment">/// Helper function that returns a function type with ArgType prepended to the</span>
<span class="comment">/// function&apos;s args.</span>
<span class="comment">/// Example:</span>
<span class="comment">///     Func    = fn(usize) void</span>
<span class="comment">///     ArgType = *Instance</span>
<span class="comment">///     --------------------------</span>
<span class="comment">///     Result  = fn(*Instance, usize) void</span>
<span class="keyword function">fn</span> <span class="function">PrependFnArg</span><span class="punctuation bracket">(</span><span class="variable parameter">Func</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation delimiter">,</span> <span class="variable parameter">ArgType</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
    <span class="keyword">const</span> <span class="variable">fn_info</span> <span class="operator">=</span> <span class="keyword import">@typeInfo</span><span class="punctuation bracket">(</span><span class="variable">Func</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">fn_info</span> <span class="operator">!=</span> <span class="punctuation delimiter">.</span><span class="constant">@&quot;fn&quot;</span><span class="punctuation bracket">)</span> <span class="function builtin">@compileError</span><span class="punctuation bracket">(</span><span class="string">&quot;First argument must be a function type&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="keyword modifier">comptime</span> <span class="keyword">var</span> <span class="variable">new_params</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">params</span><span class="punctuation delimiter">.</span><span class="variable member">len</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">]</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">builtin</span><span class="punctuation delimiter">.</span><span class="variable member">Type</span><span class="punctuation delimiter">.</span><span class="variable member">Fn</span><span class="punctuation delimiter">.</span><span class="variable member">Param</span> <span class="operator">=</span> <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
    <span class="variable">new_params</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">is_generic</span> <span class="operator">=</span> <span class="variable">false</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable member">is_noalias</span> <span class="operator">=</span> <span class="variable">false</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable member">type</span> <span class="operator">=</span> <span class="variable">ArgType</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="keyword repeat">for</span> <span class="punctuation bracket">(</span><span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">params</span><span class="punctuation delimiter">,</span> <span class="number">0</span><span class="operator">..</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|</span><span class="variable">param</span><span class="punctuation delimiter">,</span> <span class="variable">i</span><span class="punctuation bracket">|</span> <span class="punctuation bracket">{</span>
        <span class="variable">new_params</span><span class="punctuation bracket">[</span><span class="variable">i</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="variable">param</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>

    <span class="keyword return">return</span> <span class="function builtin">@Type</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
        <span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
            <span class="punctuation delimiter">.</span><span class="variable member">calling_convention</span> <span class="operator">=</span> <span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">calling_convention</span><span class="punctuation delimiter">,</span>
            <span class="punctuation delimiter">.</span><span class="variable member">is_generic</span> <span class="operator">=</span> <span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">is_generic</span><span class="punctuation delimiter">,</span>
            <span class="punctuation delimiter">.</span><span class="variable member">is_var_args</span> <span class="operator">=</span> <span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">is_var_args</span><span class="punctuation delimiter">,</span>
            <span class="punctuation delimiter">.</span><span class="variable member">return_type</span> <span class="operator">=</span> <span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">return_type</span><span class="punctuation delimiter">,</span>
            <span class="punctuation delimiter">.</span><span class="variable member">params</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="variable">new_params</span><span class="punctuation delimiter">,</span>
        <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="comment">// Conceptual sketch for Attempt 3</span>
<span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">BindAttempt3</span><span class="punctuation bracket">(</span><span class="variable parameter">Instance</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation delimiter">,</span> <span class="variable parameter">Func</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span> <span class="comment">// Func = fn(Args...)</span>
    <span class="comment">// ... type calculations ...</span>
    <span class="keyword">const</span> <span class="variable">InstanceMethod</span> <span class="operator">=</span> <span class="function call">PrependFnArg</span><span class="punctuation bracket">(</span><span class="variable">Func</span><span class="punctuation delimiter">,</span> <span class="operator">*</span><span class="variable">Instance</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span> <span class="comment">// fn(*Inst, Args...)</span>
    <span class="keyword">const</span> <span class="variable">FuncArgs</span> <span class="operator">=</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">meta</span><span class="punctuation delimiter">.</span><span class="function call">ArgsTuple</span><span class="punctuation bracket">(</span><span class="variable">Func</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span> <span class="comment">// Args</span>

    <span class="comment">// Define the nested interface struct</span>
    <span class="keyword">const</span> <span class="variable">BindInterface</span> <span class="operator">=</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
        <span class="variable member">call</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="keyword function">fn</span> <span class="punctuation bracket">(</span><span class="operator">*</span><span class="keyword">const</span> <span class="variable">BindInterface</span><span class="punctuation delimiter">,</span> <span class="type">Args</span><span class="punctuation bracket">)</span> <span class="variable">ReturnType</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

    <span class="comment">// Define the main wrapper struct</span>
    <span class="keyword return">return</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
        <span class="variable member">instance</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">Instance</span><span class="punctuation delimiter">,</span>
        <span class="variable member">method</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">InstanceMethod</span><span class="punctuation delimiter">,</span>
        <span class="variable member">interface_</span><span class="punctuation delimiter">:</span> <span class="variable">BindInterface</span><span class="punctuation delimiter">,</span> <span class="comment">// Embed the interface</span>

        <span class="keyword modifier">pub</span> <span class="keyword">const</span> <span class="variable">BoundFunction</span> <span class="operator">=</span> <span class="keyword import">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

        <span class="comment">// The helper function pointed to by BindInterface.call</span>
        <span class="keyword function">fn</span> <span class="function">callHelper</span><span class="punctuation bracket">(</span><span class="variable parameter">interface_ptr</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">BindInterface</span><span class="punctuation delimiter">,</span> <span class="punctuation bracket">)</span> <span class="variable">ReturnType</span> <span class="punctuation bracket">{</span>
            <span class="comment">// Use @fieldParentPtr to get &apos;self&apos; (the BoundFunction instance)</span>
            <span class="keyword">const</span> <span class="variable">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">BoundFunction</span> <span class="operator">=</span> <span class="keyword import">@alignCast</span><span class="punctuation bracket">(</span>
                <span class="function builtin">@fieldParentPtr</span><span class="punctuation bracket">(</span><span class="variable">BoundFunction</span><span class="punctuation delimiter">,</span> <span class="string">&quot;interface_&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">interface_ptr</span><span class="punctuation bracket">)</span>
            <span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

            <span class="comment">// Now use self.instance and self.method to call the real method</span>
            <span class="comment">// ... call self.method ...</span>
        <span class="punctuation bracket">}</span>

        <span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="variable builtin">...</span><span class="punctuation bracket">)</span> <span class="variable">BoundFunction</span> <span class="punctuation bracket">{</span>
            <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
                <span class="comment">// .interface = ...,</span>
                <span class="comment">// .method = ...,</span>
                <span class="punctuation delimiter">.</span><span class="variable member">interface_</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">call</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="variable">callHelper</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
            <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
        <span class="punctuation bracket">}</span>
        <span class="comment">// ...</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p><strong>Addressing Hurdles within Attempt 3:</strong></p><ul><li><strong>Argument Passing:</strong> The function pointer stored in <code>call</code> needs a concrete signature. We can’t define <code>InterfaceCallFnType</code> using <code>anytype</code> for the arguments because function pointers need concrete types. So we use <code>std.meta.ArgsTuple</code> to package the original function arguments.</li><li><strong>The Polymorphism Problem (The Showstopper):</strong> This <code>@fieldParentPtr</code> approach, while functional for binding a single instance and cleverly retrieving context, hits a major wall when we desire polymorphism. Consider binding methods from a <code>Person</code> and a <code>Dog</code> that share the same callback signature <code>Func</code>:<ul><li><code>Bind(Person, Func)</code> generates a unique wrapper struct type (<code>BoundPerson</code>) containing <code>BoundPerson.BindInterface</code>.</li><li><code>Bind(Dog, Func)</code> generates <em>another</em> unique wrapper type (<code>BoundDog</code>) containing <code>BoundDog.BindInterface</code>.</li><li>Even if <code>BoundPerson.BindInterface</code> and <code>BoundDog.BindInterface</code> look identical structurally, <strong>Zig considers them distinct types</strong> because they are nested within different parent types (<code>BoundPerson</code> vs. <code>BoundDog</code>).</li><li>Furthermore, the <code>callHelper</code> functions within each are subtly different, as their <code>@fieldParentPtr</code> calculation depends on the specific parent type.</li><li><strong>Result:</strong> You cannot store instances of <code>BoundPerson.BindInterface</code> and <code>BoundDog.BindInterface</code> in a common list (e.g., <code>[]SomeCommonInterfaceType</code>) or treat them uniformly. The interface type itself remains tied to the specific <code>Instance</code> used in <code>Bind</code>.</li></ul></li></ul><p><strong>Moving Forward:</strong></p><p>The limitation of this approach highlights that for true polymorphism based on the <em>callback signature</em> alone, the interface type must be decoupled from the specific <code>Instance</code> being bound. It cannot be nested within the <code>Bind</code> result if we rely on <code>@fieldParentPtr</code> for context retrieval. This necessitates a different strategy for managing the context, leading us to the final solution involving type erasure (<code>anyopaque</code>) and an external interface definition.</p><p>To achieve true polymorphism where interfaces derived from different <code>Instance</code> types (but the same <code>Func</code> signature) are themselves the <em>same type</em>, we must:</p><ol><li>Define the interface type <em>outside</em> the <code>Bind</code> function’s result.</li><li>Make the interface type depend <em>only</em> on the <code>Func</code> signature.</li><li>Find a different way to provide the necessary context (<code>BoundFunction</code> pointer) to the function called via the interface – this leads us to type erasure using <code>anyopaque</code>.</li></ol><h2>The Solution: Decoupling Binding and Interface</h2><p>The robust solution involves two distinct components working together:</p><ol><li><strong><code>Bind(Instance, Func) type</code></strong>: A generic function that creates a struct (<code>BoundFunction</code>) responsible solely for <em>capturing</em> the context. It stores the <code>*Instance</code> pointer and the <code>*const InstanceMethod</code> pointer.</li><li><strong><code>CallbackInterface(Func) type</code></strong>: A generic function that creates the <em>interface type</em> based purely on the original function signature <code>Func</code>. This interface type is the contract that API authors will use. It leverages type erasure (<code>anyopaque</code>) to hold the context generically.</li></ol><p><strong>The key shift in thinking:</strong> Instead of an API asking for a raw function pointer <code>*const MyFuncType</code>, it will now ask for an instance of <code>CallbackInterface(MyFuncType)</code>.</p><pre><code class="zig"><span class="comment">// API Definition Change:</span>
<span class="comment">// Old:</span>
<span class="keyword function">fn</span> <span class="variable">processItems</span><span class="punctuation bracket">(</span><span class="variable parameter">items</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="variable">Item</span><span class="punctuation delimiter">,</span> <span class="variable parameter">callback</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="keyword function">fn</span><span class="punctuation bracket">(</span><span class="type">Item</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span>
<span class="comment">// New:</span>
<span class="keyword function">fn</span> <span class="variable">processItems</span><span class="punctuation bracket">(</span><span class="variable parameter">items</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="variable">Item</span><span class="punctuation delimiter">,</span> <span class="variable parameter">callback</span><span class="punctuation delimiter">:</span> <span class="function call">CallbackInterface</span><span class="punctuation bracket">(</span><span class="keyword function">fn</span><span class="punctuation bracket">(</span><span class="type">Item</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span>
</code></pre>
<p>Let’s look at the code:</p><p><strong>1. The <code>CallbackInterface</code> (External and Generic)</strong></p><pre><code class="zig"><span class="comment">// Creates a type-erased callback interface type for a given function signature Func.</span>
<span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">CallbackInterface</span><span class="punctuation bracket">(</span><span class="keyword modifier">comptime</span> <span class="variable parameter">Func</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
    <span class="keyword">const</span> <span class="variable">func_info</span> <span class="operator">=</span> <span class="keyword import">@typeInfo</span><span class="punctuation bracket">(</span><span class="variable">Func</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">func_info</span> <span class="operator">!=</span> <span class="punctuation delimiter">.</span><span class="constant">@&quot;fn&quot;</span><span class="punctuation bracket">)</span> <span class="function builtin">@compileError</span><span class="punctuation bracket">(</span><span class="string">&quot;CallbackInterface expects a function type&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">func_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">is_generic</span><span class="punctuation bracket">)</span> <span class="function builtin">@compileError</span><span class="punctuation bracket">(</span><span class="string">&quot;CallbackInterface does not support generic functions&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">func_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">is_var_args</span><span class="punctuation bracket">)</span> <span class="function builtin">@compileError</span><span class="punctuation bracket">(</span><span class="string">&quot;CallbackInterface does not support var_args functions&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="keyword">const</span> <span class="variable">ArgsTupleType</span> <span class="operator">=</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">meta</span><span class="punctuation delimiter">.</span><span class="function call">ArgsTuple</span><span class="punctuation bracket">(</span><span class="variable">Func</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span> <span class="comment">// e.g., struct{&quot;0&quot;: []const u8}</span>
    <span class="keyword">const</span> <span class="variable">ReturnType</span> <span class="operator">=</span> <span class="variable">func_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">return_type</span><span class="operator">.?</span><span class="punctuation delimiter">;</span> <span class="comment">// Allow void</span>
    <span class="comment">// The required signature for our internal trampoline function</span>
    <span class="keyword">const</span> <span class="variable">FnPtrType</span> <span class="operator">=</span> <span class="operator">*</span><span class="keyword">const</span> <span class="keyword function">fn</span> <span class="punctuation bracket">(</span><span class="variable parameter">ctx</span><span class="punctuation delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="keyword">const</span> <span class="type builtin">anyopaque</span><span class="punctuation delimiter">,</span> <span class="variable parameter">args</span><span class="punctuation delimiter">:</span> <span class="type">ArgsTupleType</span><span class="punctuation bracket">)</span> <span class="variable">ReturnType</span><span class="punctuation delimiter">;</span>

    <span class="keyword return">return</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
        <span class="comment">// Stores the BoundFunction (or any context) as an opaque const pointer</span>
        <span class="variable member">ctx</span><span class="punctuation delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="keyword">const</span> <span class="type builtin">anyopaque</span><span class="punctuation delimiter">,</span>
        <span class="comment">// Stores the pointer to the trampoline function</span>
        <span class="variable member">callFn</span><span class="punctuation delimiter">:</span> <span class="variable">FnPtrType</span><span class="punctuation delimiter">,</span>

        <span class="keyword modifier">pub</span> <span class="keyword">const</span> <span class="variable">Interface</span> <span class="operator">=</span> <span class="keyword import">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

        <span class="comment">// The public method API consumers call</span>
        <span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">call</span><span class="punctuation bracket">(</span><span class="variable parameter">self</span><span class="punctuation delimiter">:</span> <span class="type">Interface</span><span class="punctuation delimiter">,</span> <span class="variable parameter">args</span><span class="punctuation delimiter">:</span> <span class="type">ArgsTupleType</span><span class="punctuation bracket">)</span> <span class="variable">ReturnType</span> <span class="punctuation bracket">{</span>
            <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">ctx</span> <span class="operator">==</span> <span class="constant builtin">null</span><span class="punctuation bracket">)</span> <span class="function builtin">@panic</span><span class="punctuation bracket">(</span><span class="string">&quot;Called uninitialized CallbackInterface&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="comment">// Simply delegate to the trampoline</span>
            <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">ReturnType</span> <span class="operator">==</span> <span class="type builtin">void</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
                <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="function call">callFn</span><span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">ctx</span><span class="punctuation delimiter">,</span> <span class="variable">args</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="punctuation bracket">}</span> <span class="keyword conditional">else</span> <span class="punctuation bracket">{</span>
                <span class="keyword return">return</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="function call">callFn</span><span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">ctx</span><span class="punctuation delimiter">,</span> <span class="variable">args</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="punctuation bracket">}</span>
        <span class="punctuation bracket">}</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<ul><li>This defines a struct whose type <em>only</em> depends on the <code>Func</code> signature.</li><li><code>ctx: ?*const anyopaque</code>: This is the type erasure part. It holds a <code>const</code> pointer to <em>anything</em>. We’ll store our <code>BoundFunction</code> pointer here.</li><li><code>callFn: FnPtrType</code>: A function pointer expecting the opaque context and the original function’s arguments packaged in a tuple (<code>ArgsTupleType</code>). This will point to our “trampoline” function.</li><li><code>call()</code>: The method users of the interface call. It simply forwards the call to <code>callFn</code>, passing the stored context and arguments. Notice the caller provides arguments as a tuple literal (e.g., <code>.{&quot;arg1&quot;, &quot;arg2&quot;}</code>).</li></ul><div class="block warning"><h1>Trampoline Functions</h1><p>A trampoline function is generally an intermediary piece of code that performs some setup or transition (like changing stack frames, adjusting calling conventions, or handling type erasure) before transferring control to another target function, often used to bridge incompatible calling mechanisms or manage complex control flow like deep recursion without blowing the stack.</p><p>In our context, it is a small intermediate function whose job is to receive generic or type-erased arguments (like an anyopaque context pointer), perform necessary type casting or setup (like casting the context back to its real type), and then “bounce” or delegate the call to the actual target function with the correctly typed arguments.</p></div><p><strong>2. The <code>Bind</code> Function (Capturing Context)</strong></p><pre><code class="zig"><span class="comment">// Creates a struct that binds an instance to a method matching Func&apos;s signature,</span>
<span class="comment">// and provides a way to get a type-erased CallbackInterface.</span>
<span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">Bind</span><span class="punctuation bracket">(</span><span class="variable parameter">Instance</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation delimiter">,</span> <span class="variable parameter">Func</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
    <span class="keyword">const</span> <span class="variable">func_info</span> <span class="operator">=</span> <span class="keyword import">@typeInfo</span><span class="punctuation bracket">(</span><span class="variable">Func</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">func_info</span> <span class="operator">!=</span> <span class="punctuation delimiter">.</span><span class="constant">@&quot;fn&quot;</span><span class="punctuation bracket">)</span> <span class="function builtin">@compileError</span><span class="punctuation bracket">(</span><span class="string">&quot;Bind expects a function type as second parameter&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">func_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">is_generic</span><span class="punctuation bracket">)</span> <span class="function builtin">@compileError</span><span class="punctuation bracket">(</span><span class="string">&quot;Binding generic functions is not supported&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">func_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">is_var_args</span><span class="punctuation bracket">)</span> <span class="function builtin">@compileError</span><span class="punctuation bracket">(</span><span class="string">&quot;Binding var_args functions is not currently supported&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="keyword">const</span> <span class="variable">ReturnType</span> <span class="operator">=</span> <span class="variable">func_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">return_type</span><span class="operator">.?</span><span class="punctuation delimiter">;</span>
    <span class="keyword">const</span> <span class="variable">OriginalParams</span> <span class="operator">=</span> <span class="variable">func_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">params</span><span class="punctuation delimiter">;</span> <span class="comment">// Needed for comptime loops</span>
    <span class="keyword">const</span> <span class="variable">ArgsTupleType</span> <span class="operator">=</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">meta</span><span class="punctuation delimiter">.</span><span class="function call">ArgsTuple</span><span class="punctuation bracket">(</span><span class="variable">Func</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">const</span> <span class="variable">InstanceMethod</span> <span class="operator">=</span> <span class="function call">PrependFnArg</span><span class="punctuation bracket">(</span><span class="variable">Func</span><span class="punctuation delimiter">,</span> <span class="operator">*</span><span class="variable">Instance</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">const</span> <span class="variable">InterfaceType</span> <span class="operator">=</span> <span class="function call">CallbackInterface</span><span class="punctuation bracket">(</span><span class="variable">Func</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="keyword return">return</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
        <span class="variable member">instance</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">Instance</span><span class="punctuation delimiter">,</span>
        <span class="variable member">method</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">InstanceMethod</span><span class="punctuation delimiter">,</span>
        <span class="keyword modifier">pub</span> <span class="keyword">const</span> <span class="variable">BoundFunction</span> <span class="operator">=</span> <span class="keyword import">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

        <span class="comment">// Trampoline function using runtime tuple construction</span>
        <span class="keyword function">fn</span> <span class="function">callDetached</span><span class="punctuation bracket">(</span><span class="variable parameter">ctx</span><span class="punctuation delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="keyword">const</span> <span class="type builtin">anyopaque</span><span class="punctuation delimiter">,</span> <span class="variable parameter">args</span><span class="punctuation delimiter">:</span> <span class="type">ArgsTupleType</span><span class="punctuation bracket">)</span> <span class="variable">ReturnType</span> <span class="punctuation bracket">{</span>
            <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">ctx</span> <span class="operator">==</span> <span class="constant builtin">null</span><span class="punctuation bracket">)</span> <span class="function builtin">@panic</span><span class="punctuation bracket">(</span><span class="string">&quot;callDetached called with null context&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="keyword">const</span> <span class="variable">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">BoundFunction</span> <span class="operator">=</span> <span class="keyword import">@ptrCast</span><span class="punctuation bracket">(</span><span class="function builtin">@alignCast</span><span class="punctuation bracket">(</span><span class="variable">ctx</span><span class="operator">.?</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

            <span class="comment">// 1. Define the tuple type needed for the call: .{*Instance, OriginalArgs...}</span>
            <span class="keyword">const</span> <span class="variable">CallArgsTupleType</span> <span class="operator">=</span> <span class="keyword modifier">comptime</span> <span class="label">T</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">{</span>
                <span class="keyword">var</span> <span class="variable">tuple_fields</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="variable">OriginalParams</span><span class="punctuation delimiter">.</span><span class="variable member">len</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">]</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">builtin</span><span class="punctuation delimiter">.</span><span class="variable member">Type</span><span class="punctuation delimiter">.</span><span class="variable member">StructField</span> <span class="operator">=</span> <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
                <span class="comment">// Field 0: *Instance type</span>
                <span class="variable">tuple_fields</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">name</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">type</span> <span class="operator">=</span> <span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">instance</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">default_value_ptr</span> <span class="operator">=</span> <span class="constant builtin">null</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">is_comptime</span> <span class="operator">=</span> <span class="variable">false</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">alignment</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation delimiter">,</span>
                <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
                <span class="comment">// Fields 1..N: Original argument types (use ArgsTupleType fields)</span>
                <span class="keyword repeat">for</span> <span class="punctuation bracket">(</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">meta</span><span class="punctuation delimiter">.</span><span class="function call">fields</span><span class="punctuation bracket">(</span><span class="variable">ArgsTupleType</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="number">0</span><span class="operator">..</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|</span><span class="variable">field</span><span class="punctuation delimiter">,</span> <span class="variable">i</span><span class="punctuation bracket">|</span> <span class="punctuation bracket">{</span>
                    <span class="variable">tuple_fields</span><span class="punctuation bracket">[</span><span class="variable">i</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
                        <span class="punctuation delimiter">.</span><span class="variable member">name</span> <span class="operator">=</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">fmt</span><span class="punctuation delimiter">.</span><span class="function call">comptimePrint</span><span class="punctuation bracket">(</span><span class="string">&quot;{d}&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">i</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
                        <span class="punctuation delimiter">.</span><span class="variable member">type</span> <span class="operator">=</span> <span class="variable">field</span><span class="punctuation delimiter">.</span><span class="variable member">type</span><span class="punctuation delimiter">,</span>
                        <span class="punctuation delimiter">.</span><span class="variable member">default_value_ptr</span> <span class="operator">=</span> <span class="constant builtin">null</span><span class="punctuation delimiter">,</span>
                        <span class="punctuation delimiter">.</span><span class="variable member">is_comptime</span> <span class="operator">=</span> <span class="variable">false</span><span class="punctuation delimiter">,</span>
                        <span class="punctuation delimiter">.</span><span class="variable member">alignment</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
                <span class="punctuation bracket">}</span>
                <span class="keyword repeat">break</span> <span class="punctuation delimiter">:</span><span class="label">T</span> <span class="function builtin">@Type</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">@&quot;struct&quot;</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">layout</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="constant">auto</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">fields</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="variable">tuple_fields</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">decls</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">is_tuple</span> <span class="operator">=</span> <span class="variable">true</span><span class="punctuation delimiter">,</span>
                <span class="punctuation bracket">}</span> <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

            <span class="comment">// 2. Create and populate the tuple at runtime</span>
            <span class="keyword">var</span> <span class="variable">call_args_tuple</span><span class="punctuation delimiter">:</span> <span class="variable">CallArgsTupleType</span> <span class="operator">=</span> <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
            <span class="function builtin">@field</span><span class="punctuation bracket">(</span><span class="variable">call_args_tuple</span><span class="punctuation delimiter">,</span> <span class="string">&quot;0&quot;</span><span class="punctuation bracket">)</span> <span class="operator">=</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">instance</span><span class="punctuation delimiter">;</span> <span class="comment">// Set the instance pointer</span>

            <span class="comment">// Copy original args from &apos;args&apos; tuple to &apos;call_args_tuple&apos;</span>
            <span class="keyword modifier">comptime</span> <span class="keyword">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation delimiter">;</span>
            <span class="keyword modifier">inline</span> <span class="keyword repeat">while</span> <span class="punctuation bracket">(</span><span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">OriginalParams</span><span class="punctuation delimiter">.</span><span class="variable member">len</span><span class="punctuation bracket">)</span> <span class="punctuation delimiter">:</span> <span class="punctuation bracket">(</span><span class="variable">i</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
                <span class="keyword">const</span> <span class="variable">src_field_name</span> <span class="operator">=</span> <span class="keyword modifier">comptime</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">fmt</span><span class="punctuation delimiter">.</span><span class="function call">comptimePrint</span><span class="punctuation bracket">(</span><span class="string">&quot;{}&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">i</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
                <span class="keyword">const</span> <span class="variable">dest_field_name</span> <span class="operator">=</span> <span class="keyword modifier">comptime</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">fmt</span><span class="punctuation delimiter">.</span><span class="function call">comptimePrint</span><span class="punctuation bracket">(</span><span class="string">&quot;{}&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">i</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
                <span class="function builtin">@field</span><span class="punctuation bracket">(</span><span class="variable">call_args_tuple</span><span class="punctuation delimiter">,</span> <span class="variable">dest_field_name</span><span class="punctuation bracket">)</span> <span class="operator">=</span> <span class="function builtin">@field</span><span class="punctuation bracket">(</span><span class="variable">args</span><span class="punctuation delimiter">,</span> <span class="variable">src_field_name</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="punctuation bracket">}</span>

            <span class="comment">// 3. Perform the call using the populated tuple</span>
            <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">ReturnType</span> <span class="operator">==</span> <span class="type builtin">void</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
                <span class="function builtin">@call</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="constant">auto</span><span class="punctuation delimiter">,</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">method</span><span class="punctuation delimiter">,</span> <span class="variable">call_args_tuple</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="punctuation bracket">}</span> <span class="keyword conditional">else</span> <span class="punctuation bracket">{</span>
                <span class="keyword return">return</span> <span class="function builtin">@call</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="constant">auto</span><span class="punctuation delimiter">,</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">method</span><span class="punctuation delimiter">,</span> <span class="variable">call_args_tuple</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="punctuation bracket">}</span>
        <span class="punctuation bracket">}</span>

        <span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">interface</span><span class="punctuation bracket">(</span><span class="variable parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">BoundFunction</span><span class="punctuation bracket">)</span> <span class="variable">InterfaceType</span> <span class="punctuation bracket">{</span>
            <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">ctx</span> <span class="operator">=</span> <span class="function builtin">@ptrCast</span><span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable member">callFn</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="variable">callDetached</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
        <span class="punctuation bracket">}</span>

        <span class="comment">// Direct call convenience method using runtime tuple construction</span>
        <span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">call</span><span class="punctuation bracket">(</span><span class="variable parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">BoundFunction</span><span class="punctuation delimiter">,</span> <span class="variable parameter">args</span><span class="punctuation delimiter">:</span> <span class="type builtin">anytype</span><span class="punctuation bracket">)</span> <span class="variable">ReturnType</span> <span class="punctuation bracket">{</span>
            <span class="comment">// 1. Verify &apos;args&apos; is the correct ArgsTupleType</span>
            <span class="comment">// (This check could be more robust if needed)</span>
            <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">args</span><span class="punctuation bracket">)</span> <span class="operator">!=</span> <span class="variable">ArgsTupleType</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
                <span class="comment">// Attempt reasonable check for tuple literal compatibility</span>
                <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="function builtin">@typeInfo</span><span class="punctuation bracket">(</span><span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">args</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="operator">!=</span> <span class="punctuation delimiter">.</span><span class="constant">@&quot;struct&quot;</span> <span class="keyword operator">or</span> <span class="operator">!</span><span class="function builtin">@typeInfo</span><span class="punctuation bracket">(</span><span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">args</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;struct&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">is_tuple</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
                    <span class="function builtin">@compileError</span><span class="punctuation bracket">(</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">fmt</span><span class="punctuation delimiter">.</span><span class="function call">comptimePrint</span><span class="punctuation bracket">(</span>
                        <span class="string">&quot;Direct .call expects arguments as a tuple literal compatible with {}, found type {}&quot;</span><span class="punctuation delimiter">,</span>
                        <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="variable">ArgsTupleType</span><span class="punctuation delimiter">,</span> <span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">args</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
                <span class="punctuation bracket">}</span>
                <span class="comment">// Further check field count/types if necessary</span>
                <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">meta</span><span class="punctuation delimiter">.</span><span class="function call">fields</span><span class="punctuation bracket">(</span><span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">args</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="variable member">len</span> <span class="operator">!=</span> <span class="variable">OriginalParams</span><span class="punctuation delimiter">.</span><span class="variable member">len</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
                    <span class="function builtin">@compileError</span><span class="punctuation bracket">(</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">fmt</span><span class="punctuation delimiter">.</span><span class="function call">comptimePrint</span><span class="punctuation bracket">(</span>
                        <span class="string">&quot;Direct .call tuple literal has wrong number of arguments (expected {}, got {}) for {}&quot;</span><span class="punctuation delimiter">,</span>
                        <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="variable">OriginalParams</span><span class="punctuation delimiter">.</span><span class="variable member">len</span><span class="punctuation delimiter">,</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">meta</span><span class="punctuation delimiter">.</span><span class="function call">fields</span><span class="punctuation bracket">(</span><span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">args</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="variable member">len</span><span class="punctuation delimiter">,</span> <span class="variable">ArgsTupleType</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
                <span class="punctuation bracket">}</span>
                <span class="comment">// Could add type checks per field here too</span>
            <span class="punctuation bracket">}</span>

            <span class="comment">// 2. Define the tuple type needed for the call: .{*Instance, OriginalArgs...}</span>
            <span class="keyword">const</span> <span class="variable">CallArgsTupleType</span> <span class="operator">=</span> <span class="keyword modifier">comptime</span> <span class="label">T</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">{</span>
                <span class="keyword">var</span> <span class="variable">tuple_fields</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="variable">OriginalParams</span><span class="punctuation delimiter">.</span><span class="variable member">len</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">]</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">builtin</span><span class="punctuation delimiter">.</span><span class="variable member">Type</span><span class="punctuation delimiter">.</span><span class="variable member">StructField</span> <span class="operator">=</span> <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
                <span class="variable">tuple_fields</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">name</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">type</span> <span class="operator">=</span> <span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">instance</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">default_value_ptr</span> <span class="operator">=</span> <span class="constant builtin">null</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">is_comptime</span> <span class="operator">=</span> <span class="variable">false</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">alignment</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation delimiter">,</span>
                <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
                <span class="keyword repeat">for</span> <span class="punctuation bracket">(</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">meta</span><span class="punctuation delimiter">.</span><span class="function call">fields</span><span class="punctuation bracket">(</span><span class="variable">ArgsTupleType</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="number">0</span><span class="operator">..</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|</span><span class="variable">field</span><span class="punctuation delimiter">,</span> <span class="variable">i</span><span class="punctuation bracket">|</span> <span class="punctuation bracket">{</span>
                    <span class="variable">tuple_fields</span><span class="punctuation bracket">[</span><span class="variable">i</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
                        <span class="punctuation delimiter">.</span><span class="variable member">name</span> <span class="operator">=</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">fmt</span><span class="punctuation delimiter">.</span><span class="function call">comptimePrint</span><span class="punctuation bracket">(</span><span class="string">&quot;{d}&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">i</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
                        <span class="punctuation delimiter">.</span><span class="variable member">type</span> <span class="operator">=</span> <span class="variable">field</span><span class="punctuation delimiter">.</span><span class="variable member">type</span><span class="punctuation delimiter">,</span>
                        <span class="punctuation delimiter">.</span><span class="variable member">default_value_ptr</span> <span class="operator">=</span> <span class="constant builtin">null</span><span class="punctuation delimiter">,</span>
                        <span class="punctuation delimiter">.</span><span class="variable member">is_comptime</span> <span class="operator">=</span> <span class="variable">false</span><span class="punctuation delimiter">,</span>
                        <span class="punctuation delimiter">.</span><span class="variable member">alignment</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
                <span class="punctuation bracket">}</span>
                <span class="keyword repeat">break</span> <span class="punctuation delimiter">:</span><span class="label">T</span> <span class="function builtin">@Type</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">@&quot;struct&quot;</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">layout</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="constant">auto</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">fields</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="variable">tuple_fields</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">decls</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
                    <span class="punctuation delimiter">.</span><span class="variable member">is_tuple</span> <span class="operator">=</span> <span class="variable">true</span><span class="punctuation delimiter">,</span>
                <span class="punctuation bracket">}</span> <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

            <span class="comment">// 3. Create and populate the tuple at runtime</span>
            <span class="keyword">var</span> <span class="variable">call_args_tuple</span><span class="punctuation delimiter">:</span> <span class="variable">CallArgsTupleType</span> <span class="operator">=</span> <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
            <span class="function builtin">@field</span><span class="punctuation bracket">(</span><span class="variable">call_args_tuple</span><span class="punctuation delimiter">,</span> <span class="string">&quot;0&quot;</span><span class="punctuation bracket">)</span> <span class="operator">=</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">instance</span><span class="punctuation delimiter">;</span>

            <span class="keyword modifier">comptime</span> <span class="keyword">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation delimiter">;</span>
            <span class="keyword modifier">inline</span> <span class="keyword repeat">while</span> <span class="punctuation bracket">(</span><span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">OriginalParams</span><span class="punctuation delimiter">.</span><span class="variable member">len</span><span class="punctuation bracket">)</span> <span class="punctuation delimiter">:</span> <span class="punctuation bracket">(</span><span class="variable">i</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
                <span class="keyword">const</span> <span class="variable">field_name</span> <span class="operator">=</span> <span class="keyword modifier">comptime</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">fmt</span><span class="punctuation delimiter">.</span><span class="function call">comptimePrint</span><span class="punctuation bracket">(</span><span class="string">&quot;{}&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">i</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
                <span class="comment">// Check if field exists in args (useful for struct literals, less for tuples)</span>
                <span class="comment">// For tuple literals, direct access should work if type check passed.</span>
                <span class="comment">// if (@hasField(@TypeOf(args), field_name)) { ... }</span>
                <span class="keyword">const</span> <span class="variable">dest_field_name</span> <span class="operator">=</span> <span class="keyword modifier">comptime</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">fmt</span><span class="punctuation delimiter">.</span><span class="function call">comptimePrint</span><span class="punctuation bracket">(</span><span class="string">&quot;{}&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">i</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
                <span class="function builtin">@field</span><span class="punctuation bracket">(</span><span class="variable">call_args_tuple</span><span class="punctuation delimiter">,</span> <span class="variable">dest_field_name</span><span class="punctuation bracket">)</span> <span class="operator">=</span> <span class="function builtin">@field</span><span class="punctuation bracket">(</span><span class="variable">args</span><span class="punctuation delimiter">,</span> <span class="variable">field_name</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="punctuation bracket">}</span>

            <span class="comment">// 4. Perform the call using the populated tuple</span>
            <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">ReturnType</span> <span class="operator">==</span> <span class="type builtin">void</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
                <span class="function builtin">@call</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="constant">auto</span><span class="punctuation delimiter">,</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">method</span><span class="punctuation delimiter">,</span> <span class="variable">call_args_tuple</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="punctuation bracket">}</span> <span class="keyword conditional">else</span> <span class="punctuation bracket">{</span>
                <span class="keyword return">return</span> <span class="function builtin">@call</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="constant">auto</span><span class="punctuation delimiter">,</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">method</span><span class="punctuation delimiter">,</span> <span class="variable">call_args_tuple</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
            <span class="punctuation bracket">}</span>
        <span class="punctuation bracket">}</span>

        <span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="variable parameter">instance_</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">Instance</span><span class="punctuation delimiter">,</span> <span class="variable parameter">method_</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">InstanceMethod</span><span class="punctuation bracket">)</span> <span class="variable">BoundFunction</span> <span class="punctuation bracket">{</span>
            <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">instance</span> <span class="operator">=</span> <span class="variable">instance_</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable member">method</span> <span class="operator">=</span> <span class="variable">method_</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
        <span class="punctuation bracket">}</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="comment">/// Helper function that returns a function type with ArgType prepended to the</span>
<span class="comment">/// function&apos;s args.</span>
<span class="comment">/// Example:</span>
<span class="comment">///     Func    = fn(usize) void</span>
<span class="comment">///     ArgType = *Instance</span>
<span class="comment">///     --------------------------</span>
<span class="comment">///     Result  = fn(*Instance, usize) void</span>
<span class="keyword function">fn</span> <span class="function">PrependFnArg</span><span class="punctuation bracket">(</span><span class="variable parameter">Func</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation delimiter">,</span> <span class="variable parameter">ArgType</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
    <span class="keyword">const</span> <span class="variable">fn_info</span> <span class="operator">=</span> <span class="keyword import">@typeInfo</span><span class="punctuation bracket">(</span><span class="variable">Func</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">fn_info</span> <span class="operator">!=</span> <span class="punctuation delimiter">.</span><span class="constant">@&quot;fn&quot;</span><span class="punctuation bracket">)</span> <span class="function builtin">@compileError</span><span class="punctuation bracket">(</span><span class="string">&quot;First argument must be a function type&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="keyword modifier">comptime</span> <span class="keyword">var</span> <span class="variable">new_params</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">params</span><span class="punctuation delimiter">.</span><span class="variable member">len</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">]</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">builtin</span><span class="punctuation delimiter">.</span><span class="variable member">Type</span><span class="punctuation delimiter">.</span><span class="variable member">Fn</span><span class="punctuation delimiter">.</span><span class="variable member">Param</span> <span class="operator">=</span> <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
    <span class="variable">new_params</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">is_generic</span> <span class="operator">=</span> <span class="variable">false</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable member">is_noalias</span> <span class="operator">=</span> <span class="variable">false</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable member">type</span> <span class="operator">=</span> <span class="variable">ArgType</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="keyword repeat">for</span> <span class="punctuation bracket">(</span><span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">params</span><span class="punctuation delimiter">,</span> <span class="number">0</span><span class="operator">..</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|</span><span class="variable">param</span><span class="punctuation delimiter">,</span> <span class="variable">i</span><span class="punctuation bracket">|</span> <span class="punctuation bracket">{</span>
        <span class="variable">new_params</span><span class="punctuation bracket">[</span><span class="variable">i</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="variable">param</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>

    <span class="keyword return">return</span> <span class="function builtin">@Type</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
        <span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
            <span class="punctuation delimiter">.</span><span class="variable member">calling_convention</span> <span class="operator">=</span> <span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">calling_convention</span><span class="punctuation delimiter">,</span>
            <span class="punctuation delimiter">.</span><span class="variable member">is_generic</span> <span class="operator">=</span> <span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">is_generic</span><span class="punctuation delimiter">,</span>
            <span class="punctuation delimiter">.</span><span class="variable member">is_var_args</span> <span class="operator">=</span> <span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">is_var_args</span><span class="punctuation delimiter">,</span>
            <span class="punctuation delimiter">.</span><span class="variable member">return_type</span> <span class="operator">=</span> <span class="variable">fn_info</span><span class="punctuation delimiter">.</span><span class="variable member">@&quot;fn&quot;</span><span class="punctuation delimiter">.</span><span class="variable member">return_type</span><span class="punctuation delimiter">,</span>
            <span class="punctuation delimiter">.</span><span class="variable member">params</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="variable">new_params</span><span class="punctuation delimiter">,</span>
        <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<ul><li><code>Bind</code> returns a <code>BoundFunction</code> struct storing <code>instance</code> and <code>method</code>.</li><li><code>callDetached</code>: This is the crucial <strong>trampoline</strong> function.<ul><li>It matches the <code>FnPtrType</code> signature required by <code>CallbackInterface</code>.</li><li>It receives the <code>anyopaque</code> context and casts it back to <code>*const BoundFunction</code>. This is safe because we <em>know</em> by construction that <code>ctx</code> will always hold a pointer to a <code>BoundFunction</code> when created via <code>interface()</code>.</li><li>It retrieves the <code>instance</code> and <code>method</code> pointers from the recovered <code>self</code>.</li><li>It constructs the final argument tuple (<code>.{self.instance, original_args...}</code>) needed by the actual <code>method</code>.</li><li>It uses <code>@call</code> to invoke the original <code>method</code>.</li></ul></li><li><code>interface()</code>: This method is called on a <code>BoundFunction</code> instance. It creates and returns a <code>CallbackInterface</code> struct, populating <code>ctx</code> with a type-erased pointer to itself and <code>callFn</code> with the address of the <code>callDetached</code> trampoline.</li></ul><p><strong>3. Putting it Together: Polymorphic Callbacks</strong></p><p>Now, our <code>Person</code> and <code>Dog</code> example works beautifully, demonstrating polymorphism:</p><pre><code class="zig"><span class="keyword">test</span> <span class="string">&quot;BindInterface Polymorphism (External)&quot;</span> <span class="punctuation bracket">{</span>
    <span class="keyword">const</span> <span class="variable">Person</span> <span class="operator">=</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
        <span class="variable member">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
        <span class="variable member">_buf</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="number">1024</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span> <span class="operator">=</span> <span class="constant builtin">undefined</span><span class="punctuation delimiter">,</span>
        <span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">speak</span><span class="punctuation bracket">(</span><span class="variable parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="function builtin">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable parameter">message</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation bracket">)</span> <span class="operator">!</span><span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span> <span class="punctuation bracket">{</span>
            <span class="keyword return">return</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">fmt</span><span class="punctuation delimiter">.</span><span class="function call">bufPrint</span><span class="punctuation bracket">(</span><span class="operator">&amp;</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">_buf</span><span class="punctuation delimiter">,</span> <span class="string">&quot;{s} says: &gt;&gt;{s}!&lt;&lt;\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">name</span><span class="punctuation delimiter">,</span> <span class="variable">message</span> <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
        <span class="punctuation bracket">}</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

    <span class="keyword">const</span> <span class="variable">Dog</span> <span class="operator">=</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
        <span class="variable member">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
        <span class="variable member">_buf</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="number">1024</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span> <span class="operator">=</span> <span class="constant builtin">undefined</span><span class="punctuation delimiter">,</span>
        <span class="keyword modifier">pub</span> <span class="keyword function">fn</span> <span class="function">bark</span><span class="punctuation bracket">(</span><span class="variable parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="function builtin">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable parameter">message</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation bracket">)</span> <span class="operator">!</span><span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span> <span class="punctuation bracket">{</span>
            <span class="keyword return">return</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="variable member">fmt</span><span class="punctuation delimiter">.</span><span class="function call">bufPrint</span><span class="punctuation bracket">(</span><span class="operator">&amp;</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">_buf</span><span class="punctuation delimiter">,</span> <span class="string">&quot;{s} barks: &gt;&gt;{s}!&lt;&lt;\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="variable member">name</span><span class="punctuation delimiter">,</span> <span class="variable">message</span> <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
        <span class="punctuation bracket">}</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

    <span class="comment">// The common callback signature</span>
    <span class="keyword">const</span> <span class="variable">CallBack</span> <span class="operator">=</span> <span class="keyword function">fn</span> <span class="punctuation bracket">(</span><span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation bracket">)</span> <span class="type builtin">anyerror</span><span class="operator">!</span><span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">;</span>
    <span class="comment">// The SINGLE interface type derived from CallBack</span>
    <span class="keyword">const</span> <span class="variable">CbInterface</span> <span class="operator">=</span> <span class="function call">CallbackInterface</span><span class="punctuation bracket">(</span><span class="variable">CallBack</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="keyword">var</span> <span class="variable">alice</span><span class="punctuation delimiter">:</span> <span class="variable">Person</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="keyword">const</span> <span class="variable">bound_alice</span> <span class="operator">=</span> <span class="function call">Bind</span><span class="punctuation bracket">(</span><span class="variable">Person</span><span class="punctuation delimiter">,</span> <span class="variable">CallBack</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function call">init</span><span class="punctuation bracket">(</span><span class="operator">&amp;</span><span class="variable">alice</span><span class="punctuation delimiter">,</span> <span class="operator">&amp;</span><span class="variable">Person</span><span class="punctuation delimiter">.</span><span class="variable member">speak</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="comment">// alice_interface has type CbInterface</span>
    <span class="keyword">const</span> <span class="variable">alice_interface</span> <span class="operator">=</span> <span class="variable">bound_alice</span><span class="punctuation delimiter">.</span><span class="function call">interface</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="keyword">var</span> <span class="variable">bob</span><span class="punctuation delimiter">:</span> <span class="variable">Dog</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="punctuation delimiter">.</span><span class="variable member">name</span> <span class="operator">=</span> <span class="string">&quot;Bob&quot;</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="keyword">const</span> <span class="variable">bound_bob</span> <span class="operator">=</span> <span class="function call">Bind</span><span class="punctuation bracket">(</span><span class="variable">Dog</span><span class="punctuation delimiter">,</span> <span class="variable">CallBack</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function call">init</span><span class="punctuation bracket">(</span><span class="operator">&amp;</span><span class="variable">bob</span><span class="punctuation delimiter">,</span> <span class="operator">&amp;</span><span class="variable">Dog</span><span class="punctuation delimiter">.</span><span class="variable member">bark</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="comment">// bob_interface ALSO has type CbInterface</span>
    <span class="keyword">const</span> <span class="variable">bob_interface</span> <span class="operator">=</span> <span class="variable">bound_bob</span><span class="punctuation delimiter">.</span><span class="function call">interface</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// We can store them in the same array!</span>
    <span class="keyword">const</span> <span class="variable">interfaces</span> <span class="operator">=</span> <span class="punctuation bracket">[</span><span class="variable">_</span><span class="punctuation bracket">]</span><span class="variable">CbInterface</span><span class="punctuation bracket">{</span> <span class="variable">alice_interface</span><span class="punctuation delimiter">,</span> <span class="variable">bob_interface</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="keyword">var</span> <span class="variable">results</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="number">2</span><span class="punctuation bracket">]</span><span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="keyword">const</span> <span class="type builtin">u8</span> <span class="operator">=</span> <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>

    <span class="comment">// The calling code uses the simple .call(args_tuple) method</span>
    <span class="keyword repeat">for</span> <span class="punctuation bracket">(</span><span class="variable">interfaces</span><span class="punctuation delimiter">,</span> <span class="number">0</span><span class="operator">..</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|</span><span class="variable">iface</span><span class="punctuation delimiter">,</span> <span class="variable">i</span><span class="punctuation bracket">|</span> <span class="punctuation bracket">{</span>
        <span class="variable">results</span><span class="punctuation bracket">[</span><span class="variable">i</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="keyword exception">try</span> <span class="variable">iface</span><span class="punctuation delimiter">.</span><span class="function call">call</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="string">&quot;Test&quot;</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>

    <span class="keyword exception">try</span> <span class="variable">testing</span><span class="punctuation delimiter">.</span><span class="function call">expectEqualStrings</span><span class="punctuation bracket">(</span><span class="string">&quot;Alice says: &gt;&gt;Test!&lt;&lt;\n&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">results</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation bracket">]</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword exception">try</span> <span class="variable">testing</span><span class="punctuation delimiter">.</span><span class="function call">expectEqualStrings</span><span class="punctuation bracket">(</span><span class="string">&quot;Bob barks: &gt;&gt;Test!&lt;&lt;\n&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">results</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation bracket">]</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Because <code>CallbackInterface(CallBack)</code> produces the <em>same type</em> regardless of whether the underlying context is a <code>Person</code> or a <code>Dog</code>, we can treat them polymorphically.</p><p>Looking back, this approach is still not as painless as Python’s bound methods, as it uses interface instances as opposed to function pointers, yet it’s the closest I could come up with so far.</p><p>Phew, that was a lot! I know. Thanks for making it this far 😊!</p><h2>Relation to Standard Zig Interfaces (VTable Pattern)</h2><p>Experienced Zig developers might recognize similarities between our <code>CallbackInterface</code> and the common pattern used for implementing interfaces like <code>std.mem.Allocator</code>. Let’s clarify the relationship.</p><p><strong>The Standard VTable/<code>anyopaque</code> Interface Pattern</strong></p><p>The typical way to create a dynamic interface in Zig involves:</p><ol><li><strong>The Interface Struct:</strong> Defines the contract, usually containing <code>ptr: *anyopaque</code> for context and function pointers (often in a <code>VTable</code> struct) for a <em>fixed set</em> of operations:<pre><code class="zig"><span class="variable member">ptr</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="type builtin">anyopaque</span><span class="punctuation delimiter">,</span>         <span class="comment">// type-erased</span>
<span class="variable member">vtable</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="variable">VTable</span><span class="punctuation delimiter">,</span>

<span class="keyword modifier">pub</span> <span class="keyword">const</span> <span class="variable">VTable</span> <span class="operator">=</span> <span class="keyword type">struct</span> <span class="punctuation bracket">{</span>
    <span class="comment">// type-erased--------v</span>
    <span class="variable member">alloc</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="keyword function">fn</span> <span class="punctuation bracket">(</span><span class="operator">*</span><span class="type builtin">anyopaque</span><span class="punctuation delimiter">,</span> <span class="variable parameter">len</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation delimiter">,</span> <span class="variable parameter">alignment</span><span class="punctuation delimiter">:</span> <span class="type">Alignment</span><span class="punctuation delimiter">,</span> <span class="variable parameter">ret_addr</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation bracket">)</span> <span class="operator">?</span><span class="punctuation bracket">[</span><span class="operator">*</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
    <span class="variable member">free</span><span class="punctuation delimiter">:</span>  <span class="operator">*</span><span class="keyword">const</span> <span class="keyword function">fn</span> <span class="punctuation bracket">(</span><span class="operator">*</span><span class="type builtin">anyopaque</span><span class="punctuation delimiter">,</span> <span class="variable parameter">memory</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="variable parameter">alignment</span><span class="punctuation delimiter">:</span> <span class="type">Alignment</span><span class="punctuation delimiter">,</span> <span class="variable parameter">ret_addr</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span><span class="punctuation delimiter">,</span>
    <span class="comment">// ...</span><span class="punctuation bracket"></span><span class="punctuation delimiter"></span>
</code></pre>
</li><li><strong>The Implementation:</strong> A concrete type providing logic for the interface methods.</li><li><strong>Type Erasure and Casting:</strong> The implementation pointer is cast to <code>*anyopaque</code> on interface creation and cast back within the actual implementation functions or trampoline functions, using <code>@ptrCast</code>/<code>@alignCast</code>.</li><li><strong>Trampolines:</strong> Functions associated with the implementation (or generated via a generic <code>Interface.init</code>) that handle the casting and delegate to the actual implementation logic.</li></ol><p><strong>How Our <code>CallbackInterface</code> + <code>Bind</code> Pattern Compares</strong></p><p>Our approach leverages the same fundamental principles but is specialized:</p><ul><li><strong>Shared Principles:</strong> Type erasure (<code>anyopaque</code>), function pointers, trampolines, and enabling polymorphism.</li><li><strong>Key Differences & Specialization:</strong><ul><li><strong>Interface Definition (Fixed Set vs. Arbitrary Single Signature):</strong> Standard interfaces (<code>Writer</code>, <code>Allocator</code>) define a <em>fixed set</em> of operations. Our <code>CallbackInterface(Func)</code> generates an interface type tailored dynamically to <em>one specific, arbitrary function signature</em> <code>Func</code>. It allows binding <em>any</em> function signature as a single-action callback interface, not just those belonging to a pre-defined suite.</li><li><strong>Context (<code>ctx</code> vs. <code>ptr</code>):</strong> Standard interfaces usually store a pointer directly to the implementation (<code>*File</code>). Our <code>ctx</code> points to the intermediate <code>BoundFunction</code> struct, which then holds the target instance and method.</li><li><strong>Trampoline Location & Knowledge:</strong> Our <code>callDetached</code> trampoline is part of the <code>Bind</code> mechanism, specifically knowing how to unpack the <code>BoundFunction</code> context. Standard trampolines are tied to the implementation type.</li><li><strong>Purpose:</strong> The standard pattern is general-purpose dynamic dispatch for a known set of operations. Ours is a specific solution for adapting <em>any single</em> instance method for callback APIs expecting a matching signature (minus <code>self</code>), enabling polymorphism based on the callback <em>signature</em> itself.</li></ul></li></ul><p><strong>When to Use Which?</strong></p><ul><li><strong>Standard VTable Interface:</strong> For general-purpose interfaces defining a contract with <em>multiple, known operations</em> (like <code>std.io.Writer</code>, <code>std.mem.Allocator</code>).</li><li><strong><code>CallbackInterface</code> + <code>Bind</code>:</strong> Specifically when adapting a <em>single instance method</em> as a callback for an API expecting a function pointer matching that method’s signature (minus <code>self</code>), especially when needing polymorphism based on that signature across different instance types.</li></ul><h3>Trade-offs</h3><ul><li><strong>Type Erasure:</strong> We use <code>anyopaque</code>, requiring a runtime cast inside <code>callDetached</code> (though safe by construction).</li><li><strong>Indirection:</strong> An extra function call via <code>callFn</code> (usually negligible).</li><li><strong>API Design:</strong> Requires APIs to adopt the <code>CallbackInterface(Func)</code> pattern.</li><li><strong>Caller Syntax:</strong> Interface callers use <code>.call(.{arg1, arg2})</code> with tuple literals.</li></ul><h3>Conclusion</h3><p>By decoupling context capture (<code>Bind</code>) from a generic, signature-driven interface (<code>CallbackInterface</code>) using type erasure and a trampoline function (<code>callDetached</code>), we achieve a powerful and flexible callback mechanism in Zig. This pattern provides a type-safe way to bind instance methods for APIs expecting simpler function pointers, enabling Python-like convenience and polymorphic behavior based on the callback signature, all while adhering to Zig’s philosophy of explicitness. It bridges the gap between instance-oriented methods and function-pointer-based APIs, with the caveat that those APIs need to be aware of it (using <code>CallbackInterface(Func)</code>) — which is fine if the API author is you <em>(me, in my case)</em>. 😊</p></div>
  </div>
  <hr>
  <div id="prev-next">
    <span>
      <a href="/blog/why-paper/">←
        <span>You Need a Sheet of Paper</span></a>
    </span>
    <span></span>
    <span></span>
    <small>&nbsp; or &nbsp;</small>
    <small>
      <a href="/">Back to the Homepage</a>
    </small>
  </div>

    </div>
    <footer id="footer">
      
    </footer>
    <script>
      document.querySelector('.hamburger').addEventListener('click', function() {
        document.querySelector('.menu').classList.toggle('active');
        console.log("CLICK");
    });
    </script>
  </body>
</html>
